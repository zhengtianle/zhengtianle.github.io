---
title: '[剑指Offer]二进制中1的个数惨案'
date: 2019-02-23 23:08:38
tags:
- Algorithm
- 剑指Offer
categories:
- Algorithm
- 剑指Offer
---

做到牛客网上这这道考察位运算的算法题，虽然很基础，但细细琢磨，却有不少“门道”。何谓之惨案呢？在对此题的一步步优化中，愈加发现自己对位运算、正负数的机器数表示等理解甚浅，尤其是在发现(n-1)&n这一神奇表达式后，我只能说，天(t)气(q)冷(l)，我(w)睡(s)了(l) 💀！

<!-- more -->

### 题目描述
{% note default %} 
[二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking) : 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
{% endnote %}

### 思路一：自身逐位右移

看到题目的第一思路便是将给定的整数二进制逐位右移，每次判断最低位是否为1。代码如下：
```java
public int NumberOf1(int n) {
    int count = 0;
    while(n != 0) {
        if((n & 1) != 0) {//判断二进制最低位是否为1
            count++;
        }
        n = n >> 1;//二进制逐位右移
    }
    return count;
}
```
**开开心心的提交，运行超时?🧐!**
自己构造测试样例本地运行，发现当n为负数时，程序进入死循环。突然惊醒梦中人，竟然忘记了负数的二进制符号位为1，导致右移高位自动补1，自然`while(n != 0)`跳不出。

**解决办法**：
将`n = n >> 1;`改为`n = n >>>1;`(>>>在java中表示无视符号位的二进制右移)。
**开开心心的提交，AC 🤪**

### 思路二：自身逐位左移

其实这也算是对初始思路负数造成的死循环的另一种解决办法：将数字1二进制逐位左移，每次与给定整数按位与判断当前位是否为1。代码如下：
```java
public int NumberOf1(int n) {
    int count = 0;
    int num = 1;
    while (num != 0) {
        if ((n & num) != 0) {
            count++;
        }
        num = num << 1;
    }
    return count;
}
```
**开开心心的提交，AC 🤪**

### 思路三：(n-1)&n

这个思路是我看讨论区某大佬写下的，主要就是循环体内使用了`(n-1)&n`表达式。以上两种思路皆是循环32次(int为4字节，1字节8位：4*8=32位)，运用`(n-1)&n`表达式循环次数降为给定整数二进制位中1的个数次(例如n=7，二进制为0111，则循环3次)。代码如下：
```java
public int NumberOf1(int n) {
    int count = 0;
    while(n != 0) {
        count++;
        n = (n-1) & n;
    }
    return count;
}
```
**满脸疑惑提交，AC!🧐?**

刚开始看到这段代码，对于`(n-1)&n`表达式很好奇，自己手动演算其作用为：**将n的二进制表示中的最低位为1的改为0**，例如n=10110(二进制)----(n-1)&n---->10100(二进制)
坦白：本菜鸡在使用负数手动演算的时候，忘记了题目中提醒的负数用补码表示(其实不提醒也应该知道)，长时间演算不得正确结果，一度怀疑此答案的正确性，后本地运行测试用例发现答案无误，再一次读题便发现提示负数用补码表示。给C语言老师、数据结构老师、算法老师、计组老师丢脸了！\_(:3」∠)\_

#### (n-1)&n的妙用

好奇的搜索了这个表达式，发现这个有趣的表达式，用好了也是一个奇技淫巧，总结以下三个妙用。

##### 妙用一:求二进制中1的个数

不解释

##### 妙用二:判断数是否为2的次幂

**核心代码：`n > 0 && ((n&(n-1)) == 0)`**
**解析**：
若`A&B == 0`，表示A与B的二进制形式没有同位为1的情况。而`(n&(n-1)) == 0`则表示n与n-1二进制中没有同位为1的情况。
考虑以下情况：n=10000100(二进制),n-1=10000011(二进制)
此情况显然不符合`(n&(n-1)) == 0`，不难发现**只有当n的二进制中只有一位是1，其余位全是0才可以使得表达式`(n&(n-1)) == 0`为真**。而这也是正数的2的次幂的判断条件，得证。

##### 妙用三：计算N!的质因数2的个数
>质因数（素因数或质因子）在数论里是指能整除给定正整数的质数。

换句话说就是求N!的二进制表示中最低位1的位置，因为N!中有几个质因子2，就表示N!的二进制表示可以往右移动几位而不丢失最低位的1。

**核心：N - (N二进制表示中1的个数)**

**手动演算**：
若N=8,即求8!的质因数2的个数，8!即为1\*2\*3\*4\*5\*6\*7\*8
1. 第一次，发现 2 4 6 8 四个具有2的质因数，即8/2=4
2. 第二次，2 4 6 8 在第一步中变为 1 2 3 4，发现只有 2 4 具有2的质因数，即8/4=2
3. 第三次，2 4 变为 1 2，只有2满足条件，即8/8=1

综上所述，8!的质因数2的个数为：(8/2) + (8/4) + (8/8)
归纳可得，**N!的质因数2的个数为：(N/2) + (N/4) + (N/8) + (N/16) + ……**

若N=10101(二进制)，利用上面归纳式：
单看最高位
(N/2) = 01000
(N/4) = 00100
(N/8) = 00010
(N/16) = 00001
相加可得 01111，即 10000 - 1
由此推及N的其他位可得：
(10101)!的质因数2的个数 = 10000 - 1 + 00100 - 1 +00001 - 1 = 10101- 3
多次演算归纳可得，**N!的质因数2的个数 = N - (N二进制表示中1的个数)**。其中N二进制表示中1的个数可以用`n&(n-1)`表达式轻松求得。

示例代码如下：
```java
public int lowestOne(int n) {
    return n - NumberOf1(n);
}
```

### 清奇思路
牛客网上有这样一个思路分享：
```java
public int NumberOf1(int n) {
    return Integer.toBinaryString(n).replaceAll("0","").length();
}
```
于是本菜鸡于当日发了这样一个说说：
虽然知道考察的点不是这个，但我还是很服气。来自菜鸡的膜拜\_(:3」∠)\_

本菜鸡好友列表某大佬在说说评论区又给出了这样回答：
`Integer.bitCount(n)`？或者优雅的使用Stream:`IntStream.range(0, 32).map(i -> (n >> i) & 0x1).sum();`

**哦，天气冷，我睡了！**
